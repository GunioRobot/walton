<html><head><title>zipmap</title></head><body><h3>zipmap</h3><ul><pre>(#(zipmap (map keyword (.keySet %)) (.values %)) javaHashMap)</pre><pre>((zipmap '[true false false] '["a" "b" "c"]) true)</pre><pre>((zipmap [:a :b :c :d] (iterate inc 0)) :b)</pre><pre>(->> [1 2 3 4 0 1 2 1 3 4 5 6 2 3 0] (partition 2 1) (clojure.contrib.seq-utils/partition-by (fn [[x y]] (< x y))) (map count) ((fn [v] [(clojure.contrib.seq-utils/reductions + 0 v) (map inc v)])) (apply zipmap) (apply max-key second))</pre><pre>(:true (zipmap [:true :false :false] ["a" "b" "c"])</pre><pre>(:true (zipmap [:true :false :false] ["a" "b" "c"]))</pre><pre>(I don't need zipmap, but this would be better than the code above right? (zipmap ["a" "b" "a"] [1 2 3])</pre><pre>(comp (partial apply zipmap) (juxt keys (comp (partial map f) vals))</pre><pre>(count (filter #(= (count (set %)) 1) (seq (zipmap (vec string1) (vec string2)))))</pre><pre>(defmacro named-map [& keys] `(zipmap (map keyword '~keys) (list ~@keys)))</pre><pre>(defn my-zipmap [keys vals]  (loop [my-map {}  my-keys (seq keys)  my-vals (seq vals)] (if (and my-keys my-vals)  (recur (assoc my-map (first my-keys) (first my-vals))  (rest my-keys)   (rest my-vals))  my-map)))</pre><pre>(doc zipmap)</pre><pre>(filter #(if (< (second %) 0.2) [(first %) (second %)]) (apply zipmap (vals {:c1 (vec (range 10)) :c2 (map (fn [x] (rand)) (vec (range 10)))})))</pre><pre>(filter (fn [[x y]] (< y 0.2)) (apply zipmap (vals {:c1 (vec (range 10)) :c2 (map (fn [x] (rand)) (vec (range 10)))})))</pre><pre>(filter (fn [[x y]] (even? y)) (zipmap (range 10) (range 1 11)))</pre><pre>(hash-map (zipmap [:foo :bar :baz] (iterate inc 0))</pre><pre>(hash-map (zipmap [:foo :bar :baz] (iterate inc 0)))</pre><pre>(into {:a 5 :d 42} (zipmap [:a :b :c] [4 5 6]))</pre><pre>(let (zipmap2 #(map %1 (vector %2 %3))) (zipmap2 identity [1 2 3 4] [:dog :cat :bat]))</pre><pre>(let [half-there (persistent! (update-in! (transient {:a (transient {:b 1})}) [:a :b] inc)) keys (keys half-there) vals (vals half-there)] (zipmap keys (map persistent! vals)))</pre><pre>(let [jhm (java.util.HashMap. {"a" 1, "b" 2, "c" 3})] (zipmap (map keyword (keys jhm)) (vals jhm)))</pre><pre>(let [ks [:a :b :c]] (into {} (zipmap ks (map name ks))))</pre><pre>(let [lst (range 10)] (zipmap lst (map #(* % -1) lst)))</pre><pre>(let [m (apply hash-map (interleave (range 1000) (range 1000 2000)))] (= m (zipmap (keys m) (vals m))))</pre><pre>(let [m {"foo" "FOO" "bar" "BAR"}] (zipmap (map keyword (keys m) (vals m))))</pre><pre>(let [m {"foo" "FOO" "bar" "BAR"}] (zipmap (map keyword (keys m)) (vals m))))</pre><pre>(let [m {:a 1 :b 2}] (zipmap (keys m) (map inc (vals m))))</pre><pre>(let [m {:a 1, :b 2, :c 3}] (zipmap (keys m) (map #(* 5 %) (vals m))))</pre><pre>(let [m {:a 1, :b 2, :c 3}] (zipmap (keys m) (map inc (vals m))))</pre><pre>(let [m {:a {:b [1, 2, 3, 4]}, :b {:c [5, 6, 7]}}] (into {} (map (fn [[k m2]] [k (zipmap (keys m2) (map #(apply + %) (vals m2)))]) m)))</pre><pre>(let [m {:foo 42 :bar 23} ] (zipmap (keys m) (map str (vals m))))</pre><pre>(let [m {:foo 42 :bar 23}] (zipmap (keys m) (map inc (vals m))))</pre><pre>(let [map {:foo 42 :bar 23} ] (zipmap (keys map) (map str (vals map))))</pre><pre>(let [orig {1 "one" 2 "two" 3 "three"}] [orig (zipmap (keys orig) (map #(* -1 %) (keys orig)))])</pre><pre>(let [orig {1 "one" 2 "two" 3 "three"}] [orig (zipmap (keys orig) (map #(* -1 %) (vals orig)))])</pre><pre>(let [x '(:foo "bar" :baz "spam")] (zipmap (take-nth 2 x) (take-nth 2 (rest x))))</pre><pre>(let [x {:a 1, :b 2}]  (zipmap (vals x) (keys x)))</pre><pre>(let [xs [[:a 1 2 3] [:b 4 5 6]]] #(zipmap (map first %) %))</pre><pre>(let [xs [[:a 1 2 3] [:b 4 5 6]]] (#(zipmap (map first %) %) xs))</pre><pre>(let [zipmap2 #(map %1 (vector %2 %3))] (zipmap2 identity [1 2 3 4] [:dog :cat :bat]))</pre><pre>(letfn [(double-value [m] (zipmap (keys m) (map #(if (map? %) (double-value %) (* 2 %)) (vals m))))] (double-value {:a 1, :b 2, :c {:d 3, :e 4, :f {:g 5}, :h 6}}))</pre><pre>(map #(zipmap ["a" "b"] %) [[1 2] [3 4]])</pre><pre>(map second (vals (assoc-in (zipmap (map :name users) (indexed users)) ["rick" 1 :foo] "baz")))</pre><pre>(map val (sort-by key (zipmap (repeatedly rand) (range 10) )))</pre><pre>(merge (zipmap keys values) (zipmap values keys))</pre><pre>(merge old-map (zipmap filenames uuids))</pre><pre>(my-zipmap [:a :b :c] [1 2 3])</pre><pre>(named-map :x :y :z) => (zipmap [:x :y :z] [x y z])</pre><pre>(or I guess zipmap)</pre><pre>(seq (zipmap ...))</pre><pre>(sort-by < (zipmap (range 1 100) foo))</pre><pre>(true (zipmap ...))</pre><pre>(values (zipmap (map function pairs) pairs))? Create a map with the results as the keys and the pairs as the values, which will necessarily only include unique keys (results), then take the values (pairs)</pre><pre>(vec (zipmap [1 2 3] [:a :b :c]))</pre><pre>(zipmap "'<>\"&" (map #(str \& % \;) '[apos lt gt quot amp]))</pre><pre>(zipmap "({[<" ")}]>")</pre><pre>(zipmap '("clojure" "is" "cool") (repeat :word))</pre><pre>(zipmap '(:id :name :age) '(123 "Bob" 29))</pre><pre>(zipmap '(s c) '(b d))</pre><pre>(zipmap '[a b c] '(1 2 3))</pre><pre>(zipmap '[true false false] '["a" "b" "c"])</pre><pre>(zipmap ("clojure" "is" "cool") (repeat :word)), cause i get {("clojure" "is" "cool")</pre><pre>(zipmap (:a :b) '(((1 2 3) (4 5 6))))</pre><pre>(zipmap (iterate inc 0) (enumeration-seq (-> table .getColumnModel .getColumns)))</pre><pre>(zipmap (keys m) (map f (vals m)))</pre><pre>(zipmap (keys the-map) (map f (vals the-map)</pre><pre>(zipmap (keys the-map) (vals ...))</pre><pre>(zipmap (keys themap) (vals themap))</pre><pre>(zipmap (list tokens) (repeat :word))</pre><pre>(zipmap (map #(.someMethod %) lst) lst)</pre><pre>(zipmap (map convert (keys mymap)) (vals mymap))</pre><pre>(zipmap (map f (keys m)) (vals m))</pre><pre>(zipmap (map first blah) blah)</pre><pre>(zipmap (map func vals) vals)</pre><pre>(zipmap (map keyword (keys the-map)) (vals the-map))</pre><pre>(zipmap (vector generating-array) final-generated-array)</pre><pre>(zipmap [ "clojure" "is" "cool" ] [:word :word :word])</pre><pre>(zipmap ["a" "b" "c"] [1 2 3])</pre><pre>(zipmap ["clojure" "is" "cool"] (iterate :word))</pre><pre>(zipmap ["clojure" "is" "cool"] (repeat 3 :word))</pre><pre>(zipmap ['a' 'b' 'c'] [1 2 3])</pre><pre>(zipmap [1 1] [3 4])</pre><pre>(zipmap [1 2 3 4] ["a" "b" "c" "d"])</pre><pre>(zipmap [1 2 3 4] [4 5 6 7])</pre><pre>(zipmap [1 2 3] (repeat 42))</pre><pre>(zipmap [1 2] [3 4])</pre><pre>(zipmap [:a :b :c] (pmap foo [1 2 3]))</pre><pre>(zipmap [:a :b :c] (range 3))</pre><pre>(zipmap [:a :b :c] [1 2 3])</pre><pre>(zipmap [:a :b] '((1 2 3) (4 5 6)))</pre><pre>(zipmap [:a :b] [1 2])</pre><pre>(zipmap [:a :b] [[1 2 3] [4 5 6]])</pre><pre>(zipmap [:first :first :second] [1 2 3])</pre><pre>(zipmap [:first :last] ["Bob" "Smith"])</pre><pre>(zipmap [:foo :bar :baz] (iterate inc 0))</pre><pre>(zipmap [:foo :bar] [1 2])</pre><pre>(zipmap [:k1 :k2] [:v1 :v2])</pre><pre>(zipmap [:word :word :word] ["clojure" "is" "cool"])</pre><pre>(zipmap [key1 key2] [val1 val2]) vs. (apply hash-map (apply concat [key1 val1] [key2 val2]))</pre><pre>(zipmap keys (map keys themap))</pre><pre>(zipmap my-str (iterate inc 0))</pre><pre>(zipmap structure (map ...))</pre><pre>(zipmap tokens (repeat :word))</pre><pre>(zipmap x y), but the order is random (because it's a hash map by default I guess)</pre><pre>(zipmap your-list (map f your-list))</pre><pre>(zipmap, contrib indexed)</pre></ul></body></html>